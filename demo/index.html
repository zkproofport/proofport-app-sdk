<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>ProofPort SDK Demo</title>
  <style>
    :root {
      --primary: #6366f1;
      --primary-hover: #4f46e5;
      --success: #22c55e;
      --error: #ef4444;
      --bg: #0f172a;
      --card-bg: #1e293b;
      --text: #f1f5f9;
      --text-muted: #94a3b8;
      --border: #334155;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
      padding: 2rem;
    }

    .container {
      max-width: 800px;
      margin: 0 auto;
    }

    h1 {
      font-size: 2rem;
      margin-bottom: 0.5rem;
      background: linear-gradient(135deg, var(--primary), #a855f7);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
    }

    .subtitle {
      color: var(--text-muted);
      margin-bottom: 2rem;
    }

    .tabs {
      display: flex;
      gap: 0.5rem;
      margin-bottom: 1.5rem;
    }

    .tab {
      padding: 0.75rem 1.5rem;
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: 0.5rem;
      color: var(--text-muted);
      cursor: pointer;
      transition: all 0.2s;
    }

    .tab:hover {
      border-color: var(--primary);
    }

    .tab.active {
      background: var(--primary);
      border-color: var(--primary);
      color: white;
    }

    .card {
      background: var(--card-bg);
      border: 1px solid var(--border);
      border-radius: 1rem;
      padding: 1.5rem;
      margin-bottom: 1.5rem;
    }

    .card-title {
      font-size: 1.25rem;
      margin-bottom: 1rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .form-group {
      margin-bottom: 1rem;
    }

    label {
      display: block;
      color: var(--text-muted);
      font-size: 0.875rem;
      margin-bottom: 0.5rem;
    }

    input, select {
      width: 100%;
      padding: 0.75rem 1rem;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: 0.5rem;
      color: var(--text);
      font-size: 1rem;
    }

    input:focus, select:focus {
      outline: none;
      border-color: var(--primary);
    }

    input.error {
      border-color: var(--error);
    }

    .error-text {
      color: var(--error);
      font-size: 0.75rem;
      margin-top: 0.25rem;
    }

    .btn {
      padding: 0.75rem 1.5rem;
      background: var(--primary);
      border: none;
      border-radius: 0.5rem;
      color: white;
      font-size: 1rem;
      cursor: pointer;
      transition: background 0.2s;
    }

    .btn:hover {
      background: var(--primary-hover);
    }

    .btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .btn-secondary {
      background: transparent;
      border: 1px solid var(--border);
    }

    .btn-secondary:hover {
      border-color: var(--primary);
      background: transparent;
    }

    .btn-group {
      display: flex;
      gap: 0.5rem;
      margin-top: 1rem;
    }

    .qr-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      padding: 2rem;
      background: white;
      border-radius: 1rem;
      margin: 1rem 0;
    }

    .qr-container img {
      max-width: 250px;
    }

    .qr-hint {
      color: #333;
      margin-top: 1rem;
      font-size: 0.875rem;
      text-align: center;
    }

    .deeplink-url {
      word-break: break-all;
      padding: 1rem;
      background: var(--bg);
      border-radius: 0.5rem;
      font-family: monospace;
      font-size: 0.75rem;
      color: var(--text-muted);
      margin-top: 1rem;
    }

    .result {
      padding: 1rem;
      border-radius: 0.5rem;
      margin-top: 1rem;
    }

    .result.success {
      background: rgba(34, 197, 94, 0.1);
      border: 1px solid var(--success);
    }

    .result.error {
      background: rgba(239, 68, 68, 0.1);
      border: 1px solid var(--error);
    }

    .result-title {
      font-weight: 600;
      margin-bottom: 0.5rem;
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .result.success .result-title {
      color: var(--success);
    }

    .result.error .result-title {
      color: var(--error);
    }

    .hidden {
      display: none;
    }

    .info-box {
      padding: 1rem;
      background: rgba(99, 102, 241, 0.1);
      border: 1px solid var(--primary);
      border-radius: 0.5rem;
      margin-bottom: 1rem;
      font-size: 0.875rem;
    }

    .info-box.warning {
      background: rgba(234, 179, 8, 0.1);
      border-color: #eab308;
    }

    .status-badge {
      display: inline-block;
      padding: 0.25rem 0.75rem;
      border-radius: 1rem;
      font-size: 0.75rem;
      font-weight: 600;
    }

    .status-badge.pending {
      background: rgba(234, 179, 8, 0.2);
      color: #eab308;
    }

    .status-badge.completed {
      background: rgba(34, 197, 94, 0.2);
      color: var(--success);
    }

    .status-badge.error {
      background: rgba(239, 68, 68, 0.2);
      color: var(--error);
    }

    .copy-btn {
      padding: 0.25rem 0.5rem;
      font-size: 0.75rem;
      background: var(--border);
      border: none;
      border-radius: 0.25rem;
      color: var(--text);
      cursor: pointer;
    }

    .copy-btn:hover {
      background: var(--primary);
    }

    @media (max-width: 640px) {
      body {
        padding: 1rem;
      }

      h1 {
        font-size: 1.5rem;
      }

      .tabs {
        flex-direction: column;
      }

      .btn-group {
        flex-direction: column;
      }
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>ğŸ” ProofPort SDK Demo</h1>
    <p class="subtitle">ZK Proof ìš”ì²­ ë° ê²€ì¦ í…ŒìŠ¤íŠ¸</p>

    <!-- Circuit Selection Tabs -->
    <div class="tabs">
      <button class="tab active" data-circuit="age_verifier">
        ğŸ‚ Age Verifier
      </button>
      <button class="tab" data-circuit="coinbase_attestation">
        ğŸ¦ Coinbase KYC
      </button>
    </div>

    <!-- Age Verifier Form -->
    <div id="age-form" class="card">
      <h2 class="card-title">ğŸ“‹ Age Verification Request</h2>
      <div class="info-box">
        ì¶œìƒë…„ë„ë¥¼ ê³µê°œí•˜ì§€ ì•Šê³  ë‚˜ì´ ìš”ê±´ì„ ì¶©ì¡±í•˜ëŠ”ì§€ ì¦ëª…í•©ë‹ˆë‹¤.<br>
        <strong>ëª¨ë“  ì…ë ¥ê°’ì€ ì•±ìœ¼ë¡œ ì „ë‹¬ë˜ì–´ ìë™ìœ¼ë¡œ ê²€ì¦ì´ ì‹œì‘ë©ë‹ˆë‹¤.</strong>
      </div>

      <div class="form-group">
        <label for="birthYear">Birth Year (ë¹„ê³µê°œ) *</label>
        <input type="number" id="birthYear" value="2000" min="1900" max="2025" required>
        <div class="error-text hidden" id="birthYear-error"></div>
      </div>

      <div class="form-group">
        <label for="currentYear">Current Year *</label>
        <input type="number" id="currentYear" value="2026" min="2020" max="2100" required>
        <div class="error-text hidden" id="currentYear-error"></div>
      </div>

      <div class="form-group">
        <label for="minAge">Minimum Age *</label>
        <input type="number" id="minAge" value="18" min="1" max="150" required>
        <div class="error-text hidden" id="minAge-error"></div>
      </div>

      <div class="form-group">
        <label for="callbackUrl">Callback URL (ë¹„ì›Œë‘ë©´ ë°ëª¨ ì„œë²„ë¡œ ê²°ê³¼ ìˆ˜ì‹ )</label>
        <input type="url" id="callbackUrl" placeholder="ë¹„ì›Œë‘ë©´ ì„œë²„ ì½œë°± ì—”ë“œí¬ì¸íŠ¸ ì‚¬ìš©">
      </div>

      <div class="btn-group">
        <button class="btn" onclick="createAgeRequest()">ğŸ”— Generate Deep Link</button>
        <button class="btn btn-secondary" onclick="createAgeQR()">ğŸ“± Generate QR Code</button>
      </div>
    </div>

    <!-- Coinbase KYC Form -->
    <div id="coinbase-form" class="card hidden">
      <h2 class="card-title">ğŸ“‹ Coinbase KYC Request</h2>
      <div class="info-box warning">
        <strong>ğŸ”’ Coinbase KYCëŠ” ì§€ê°‘ ì£¼ì†Œ ì…ë ¥ì´ í•„ìš” ì—†ìŠµë‹ˆë‹¤!</strong><br><br>
        â€¢ Deep Linkë¥¼ í†µí•´ ì•±ì´ ì—´ë¦¬ë©´ <strong>ì•±ì—ì„œ ìë™ìœ¼ë¡œ ì§€ê°‘ ì—°ê²°</strong>ì„ ì‹œë„í•©ë‹ˆë‹¤.<br>
        â€¢ ì—°ê²°ëœ ì§€ê°‘ ì£¼ì†Œë¡œ Etherscanì—ì„œ Coinbase ì¸ì¦ íŠ¸ëœì­ì…˜ì„ ê²€ìƒ‰í•©ë‹ˆë‹¤.<br>
        â€¢ ì‚¬ìš©ìì˜ ì‹¤ì œ ì§€ê°‘ìœ¼ë¡œë§Œ ì¦ëª…ì´ ê°€ëŠ¥í•©ë‹ˆë‹¤.
      </div>

      <div class="form-group">
        <label for="coinbaseCallbackUrl">Callback URL (ë¹„ì›Œë‘ë©´ ë°ëª¨ ì„œë²„ë¡œ ê²°ê³¼ ìˆ˜ì‹ )</label>
        <input type="url" id="coinbaseCallbackUrl" placeholder="ë¹„ì›Œë‘ë©´ ì„œë²„ ì½œë°± ì—”ë“œí¬ì¸íŠ¸ ì‚¬ìš©">
      </div>

      <div class="form-group">
        <label for="coinbaseMessage">ì‚¬ìš©ìì—ê²Œ í‘œì‹œí•  ë©”ì‹œì§€ (ì„ íƒ)</label>
        <input type="text" id="coinbaseMessage" placeholder="ì˜ˆ: ì„œë¹„ìŠ¤ ì´ìš©ì„ ìœ„í•´ Coinbase ë³¸ì¸ì¸ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤.">
      </div>

      <div class="btn-group">
        <button class="btn" onclick="createCoinbaseRequest()">ğŸ”— Generate Deep Link</button>
        <button class="btn btn-secondary" onclick="createCoinbaseQR()">ğŸ“± Generate QR Code</button>
      </div>
    </div>

    <!-- Generated Request -->
    <div id="request-result" class="card hidden">
      <h2 class="card-title">ğŸ“¤ Generated Request</h2>

      <div style="margin-bottom: 1rem;">
        <span class="status-badge pending" id="request-status">Pending</span>
        <span style="margin-left: 0.5rem; color: var(--text-muted); font-size: 0.875rem;">
          Request ID: <code id="request-id"></code>
        </span>
        <span style="margin-left: 0.5rem; color: var(--text-muted); font-size: 0.875rem;">
          Circuit: <code id="request-circuit"></code>
        </span>
      </div>

      <!-- QR Code Display -->
      <div id="qr-display" class="qr-container hidden">
        <img id="qr-image" alt="QR Code">
        <p class="qr-hint">ProofPort ì•±ìœ¼ë¡œ ìŠ¤ìº”í•˜ì„¸ìš”<br><small>ì•±ì—ì„œ ìë™ìœ¼ë¡œ ê²€ì¦ì´ ì‹œì‘ë©ë‹ˆë‹¤</small></p>
      </div>

      <!-- Deep Link Display -->
      <div id="deeplink-display" class="hidden">
        <div class="btn-group" style="margin: 0;">
          <button class="btn" onclick="openDeepLink()">ğŸ“± ì•±ì—ì„œ ì—´ê¸°</button>
          <button class="copy-btn" onclick="copyDeepLink()">ğŸ“‹ ë³µì‚¬</button>
        </div>
        <div class="deeplink-url" id="deeplink-url"></div>
      </div>
    </div>

    <!-- Proof Verification -->
    <div id="verify-section" class="card">
      <h2 class="card-title">âœ… Proof Verification</h2>
      <div class="info-box">
        ì•±ì—ì„œ ìƒì„±ëœ Proofë¥¼ ì—¬ê¸°ì— ë¶™ì—¬ë„£ì–´ ê²€ì¦í•˜ì„¸ìš”.<br>
        Callback URLë¡œ ì „ë‹¬ëœ ì‘ë‹µì€ ìë™ìœ¼ë¡œ ì²˜ë¦¬ë©ë‹ˆë‹¤.
      </div>

      <div class="form-group">
        <label for="proofInput">Proof (hex)</label>
        <input type="text" id="proofInput" placeholder="0x...">
      </div>

      <div class="form-group">
        <label for="publicInputsInput">Public Inputs (comma separated)</label>
        <input type="text" id="publicInputsInput" placeholder="0x..., 0x...">
      </div>

      <div class="form-group">
        <label for="verifyCircuit">Circuit</label>
        <select id="verifyCircuit">
          <option value="age_verifier">Age Verifier</option>
          <option value="coinbase_attestation">Coinbase KYC</option>
        </select>
      </div>

      <div class="btn-group">
        <button class="btn" onclick="verifyProofOnChain()">ğŸ”— On-chain ê²€ì¦ (Sepolia)</button>
      </div>

      <div id="verify-result" class="hidden"></div>
    </div>

    <!-- Logs -->
    <div class="card">
      <h2 class="card-title">ğŸ“ Logs</h2>
      <div id="logs" style="font-family: monospace; font-size: 0.75rem; max-height: 200px; overflow-y: auto; background: var(--bg); padding: 1rem; border-radius: 0.5rem;">
        <div style="color: var(--text-muted);">Ready...</div>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/canvas-confetti@1.9.2/dist/confetti.browser.min.js"></script>
  <script type="module">
    const DEFAULT_SCHEME = 'zkproofport';
    const SERVER_URL = window.location.origin; // Same origin as server
    const CALLBACK_URL = `${SERVER_URL}/callback`;
    const POLL_INTERVAL = 2000; // Poll every 2 seconds

    // Get local network IP for QR code callbacks (mobile devices can't reach localhost)
    let LOCAL_IP_CALLBACK_URL = CALLBACK_URL;

    // Try to detect if we need to use a different callback URL for QR codes
    function getQRCallbackUrl() {
      // If user specified a custom callback URL, use that
      const customUrl = document.getElementById('callbackUrl')?.value ||
                        document.getElementById('coinbaseCallbackUrl')?.value;
      if (customUrl) return customUrl;

      // If accessing via IP already, use the same
      if (!window.location.hostname.includes('localhost') &&
          !window.location.hostname.includes('127.0.0.1')) {
        return CALLBACK_URL;
      }

      // Otherwise show warning about localhost
      return null;
    }

    // Get local IP hint (best effort)
    async function getLocalIPHint() {
      try {
        // Try WebRTC method to get local IP
        const pc = new RTCPeerConnection({ iceServers: [] });
        pc.createDataChannel('');
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);

        return new Promise((resolve) => {
          pc.onicecandidate = (e) => {
            if (e.candidate) {
              const match = e.candidate.candidate.match(/(\d+\.\d+\.\d+\.\d+)/);
              if (match && !match[1].startsWith('127.')) {
                pc.close();
                resolve(match[1]);
              }
            }
          };
          // Fallback after timeout
          setTimeout(() => {
            pc.close();
            resolve('<YOUR_LOCAL_IP>');
          }, 1000);
        });
      } catch {
        return '<YOUR_LOCAL_IP>';
      }
    }

    let currentRequest = null;
    let currentDeepLink = null;
    let currentCircuit = 'age_verifier';
    let pollingTimer = null;

    // Confetti celebration animation
    function celebrate() {
      const duration = 3000;
      const end = Date.now() + duration;

      (function frame() {
        confetti({
          particleCount: 3,
          angle: 60,
          spread: 55,
          origin: { x: 0 },
          colors: ['#6366f1', '#a855f7', '#22c55e']
        });
        confetti({
          particleCount: 3,
          angle: 120,
          spread: 55,
          origin: { x: 1 },
          colors: ['#6366f1', '#a855f7', '#22c55e']
        });

        if (Date.now() < end) {
          requestAnimationFrame(frame);
        }
      })();
    }

    // Utility functions
    function generateRequestId() {
      const timestamp = Date.now().toString(36);
      const random = Math.random().toString(36).substring(2, 10);
      return `req-${timestamp}-${random}`;
    }

    function encodeData(data) {
      const json = JSON.stringify(data);
      // UTF-8 ë¬¸ìì—´ì„ ë¨¼ì € percent encoding í›„ btoa ì ìš© (í•œê¸€ ë“± ì§€ì›)
      const utf8Encoded = encodeURIComponent(json).replace(/%([0-9A-F]{2})/g, (_, p1) =>
        String.fromCharCode(parseInt(p1, 16))
      );
      return btoa(utf8Encoded)
        .replace(/\+/g, '-')
        .replace(/\//g, '_')
        .replace(/=+$/, '');
    }

    function buildProofRequestUrl(request) {
      const encoded = encodeData(request);
      return `${DEFAULT_SCHEME}://proof-request?data=${encoded}`;
    }

    function log(message, type = 'info') {
      const logsDiv = document.getElementById('logs');
      const colors = {
        info: 'var(--text-muted)',
        success: 'var(--success)',
        error: 'var(--error)',
        warning: '#eab308'
      };
      const time = new Date().toLocaleTimeString();
      logsDiv.innerHTML += `<div style="color: ${colors[type]}">[${time}] ${message}</div>`;
      logsDiv.scrollTop = logsDiv.scrollHeight;
    }

    function clearError(fieldId) {
      const input = document.getElementById(fieldId);
      const errorDiv = document.getElementById(`${fieldId}-error`);
      if (input) input.classList.remove('error');
      if (errorDiv) {
        errorDiv.classList.add('hidden');
        errorDiv.textContent = '';
      }
    }

    function showError(fieldId, message) {
      const input = document.getElementById(fieldId);
      const errorDiv = document.getElementById(`${fieldId}-error`);
      if (input) input.classList.add('error');
      if (errorDiv) {
        errorDiv.classList.remove('hidden');
        errorDiv.textContent = message;
      }
    }

    // Stop polling
    function stopPolling() {
      if (pollingTimer) {
        clearInterval(pollingTimer);
        pollingTimer = null;
        log('Polling stopped');
      }
    }

    // Start polling for result
    function startPolling(requestId) {
      stopPolling(); // Clear any existing polling

      log(`Starting to poll for request: ${requestId}`, 'info');
      document.getElementById('request-status').textContent = 'ìš”ì²­ ì¤‘...';
      document.getElementById('request-status').className = 'status-badge pending';

      pollingTimer = setInterval(async () => {
        try {
          const response = await fetch(`${SERVER_URL}/status/${requestId}`);
          const data = await response.json();

          if (data.found) {
            stopPolling();
            handleProofResult(data.data);
          }
        } catch (e) {
          log(`Polling error: ${e.message}`, 'error');
        }
      }, POLL_INTERVAL);

      // Also poll immediately
      (async () => {
        try {
          const response = await fetch(`${SERVER_URL}/status/${requestId}`);
          const data = await response.json();
          if (data.found) {
            stopPolling();
            handleProofResult(data.data);
          }
        } catch (e) {
          // Ignore initial poll error
        }
      })();
    }

    // Handle proof result received from server
    function handleProofResult(data) {
      const {
        requestId, status, proof, publicInputs, numPublicInputs, circuit, error,
        verificationType, verificationResult, startedAt, completedAt, expiresAt, inputs
      } = data;

      log(`=== Proof Result Received ===`, 'info');
      log(`Request ID: ${requestId}`, 'info');
      log(`Status: ${status}`, status === 'completed' ? 'success' : 'error');

      const resultDiv = document.getElementById('request-result');
      resultDiv.classList.remove('hidden');
      document.getElementById('request-id').textContent = requestId;

      // Remove any existing result messages
      const existingResults = resultDiv.querySelectorAll('.result');
      existingResults.forEach(el => el.remove());

      if (status === 'completed') {
        // Log verification details
        if (verificationType) {
          log(`Verification Type: ${verificationType}`, 'info');
        }
        if (verificationResult !== undefined) {
          log(`Verification Result: ${verificationResult ? 'âœ… VALID' : 'âŒ INVALID'}`, verificationResult ? 'success' : 'error');
        }

        // Log timing info
        if (startedAt) {
          log(`Started At: ${new Date(startedAt).toLocaleString()}`, 'info');
        }
        if (completedAt) {
          log(`Completed At: ${new Date(completedAt).toLocaleString()}`, 'info');
        }
        if (startedAt && completedAt) {
          const duration = ((completedAt - startedAt) / 1000).toFixed(2);
          log(`Duration: ${duration}s`, 'info');
        }
        if (expiresAt) {
          log(`Expires At: ${new Date(expiresAt).toLocaleString()}`, 'info');
        }

        // Log original inputs
        if (inputs && Object.keys(inputs).length > 0) {
          log(`Original Inputs: ${JSON.stringify(inputs)}`, 'info');
        }

        if (proof) {
          document.getElementById('proofInput').value = proof;
          log(`Proof: ${proof.substring(0, 60)}...`, 'success');
        }
        if (publicInputs) {
          const publicInputsStr = Array.isArray(publicInputs) ? publicInputs.join(', ') : publicInputs;
          document.getElementById('publicInputsInput').value = publicInputsStr;
          log(`Public Inputs: ${publicInputsStr}`, 'success');
        }
        if (circuit) {
          document.getElementById('verifyCircuit').value = circuit;
          document.getElementById('request-circuit').textContent = circuit;
          log(`Circuit: ${circuit}`, 'info');
        }
        if (numPublicInputs) {
          log(`Number of Public Inputs: ${numPublicInputs}`, 'info');
        }

        // Update status badge based on verification result
        const isVerified = verificationResult === true;
        document.getElementById('request-status').textContent = isVerified ? 'Verified âœ…' : 'Completed';
        document.getElementById('request-status').className = 'status-badge completed';

        // Celebrate on success!
        if (isVerified) {
          celebrate();
        }

        // Hide QR/deeplink displays
        document.getElementById('qr-display').classList.add('hidden');
        document.getElementById('deeplink-display').classList.add('hidden');

        // Build timing info string
        let timingInfo = '';
        if (startedAt && completedAt) {
          const duration = ((completedAt - startedAt) / 1000).toFixed(2);
          timingInfo = `<br><small>Duration: ${duration}s</small>`;
        }

        // Show success result with verification details
        const successHtml = `
          <div class="result success" style="margin-top: 1rem;">
            <div class="result-title">âœ… Proof Received from App!</div>
            <p>
              <strong>Verification Type:</strong> ${verificationType || 'N/A'}<br>
              <strong>Verification Result:</strong> ${verificationResult === true ? 'âœ… VALID' : verificationResult === false ? 'âŒ INVALID' : 'N/A'}
              ${timingInfo}
            </p>
            ${inputs ? `<p style="font-size: 0.75rem; margin-top: 0.5rem; color: var(--text-muted);">Inputs: ${JSON.stringify(inputs)}</p>` : ''}
            <p style="font-size: 0.875rem; margin-top: 0.5rem;">
              ${verificationResult ? 'The proof has been verified on-chain.' : 'You can verify the proof again using the section below.'}
            </p>
          </div>
        `;
        resultDiv.insertAdjacentHTML('beforeend', successHtml);

        // Scroll to verification section
        document.getElementById('verify-section').scrollIntoView({ behavior: 'smooth', block: 'start' });

        log('=== Proof Processing Complete ===', 'success');

      } else if (status === 'error') {
        log(`Error from app: ${error}`, 'error');

        document.getElementById('request-status').textContent = 'Error';
        document.getElementById('request-status').className = 'status-badge error';

        // Show error
        const errorHtml = `
          <div class="result error" style="margin-top: 1rem;">
            <div class="result-title">âŒ Error</div>
            <p>${error || 'Unknown error occurred'}</p>
          </div>
        `;
        resultDiv.insertAdjacentHTML('beforeend', errorHtml);

      } else if (status === 'cancelled') {
        log('Request was cancelled by user', 'warning');

        document.getElementById('request-status').textContent = 'Cancelled';
        document.getElementById('request-status').className = 'status-badge error';

        // Show cancelled
        const cancelHtml = `
          <div class="result error" style="margin-top: 1rem;">
            <div class="result-title">ğŸš« Cancelled</div>
            <p>The user cancelled the proof request.</p>
          </div>
        `;
        resultDiv.insertAdjacentHTML('beforeend', cancelHtml);
      }
    }

    // Clear generated request when switching tabs
    function clearRequestResult() {
      stopPolling();
      currentRequest = null;
      currentDeepLink = null;
      const resultDiv = document.getElementById('request-result');
      resultDiv.classList.add('hidden');
      document.getElementById('qr-display').classList.add('hidden');
      document.getElementById('deeplink-display').classList.add('hidden');
      document.getElementById('request-status').textContent = 'Pending';
      document.getElementById('request-status').className = 'status-badge pending';
    }

    // Tab switching
    document.querySelectorAll('.tab').forEach(tab => {
      tab.addEventListener('click', () => {
        document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
        tab.classList.add('active');

        currentCircuit = tab.dataset.circuit;
        document.getElementById('age-form').classList.toggle('hidden', currentCircuit !== 'age_verifier');
        document.getElementById('coinbase-form').classList.toggle('hidden', currentCircuit !== 'coinbase_attestation');

        // Clear previous request when switching tabs
        clearRequestResult();

        log(`Switched to ${currentCircuit} circuit`);
      });
    });

    // Validate Age Verifier inputs
    function validateAgeInputs() {
      let valid = true;

      const birthYear = parseInt(document.getElementById('birthYear').value);
      const currentYear = parseInt(document.getElementById('currentYear').value);
      const minAge = parseInt(document.getElementById('minAge').value);

      clearError('birthYear');
      clearError('currentYear');
      clearError('minAge');

      if (!birthYear || birthYear < 1900 || birthYear > 2025) {
        showError('birthYear', '1900-2025 ì‚¬ì´ì˜ ê°’ì„ ì…ë ¥í•˜ì„¸ìš”');
        valid = false;
      }

      if (!currentYear || currentYear < 2020 || currentYear > 2100) {
        showError('currentYear', '2020-2100 ì‚¬ì´ì˜ ê°’ì„ ì…ë ¥í•˜ì„¸ìš”');
        valid = false;
      }

      if (!minAge || minAge < 1 || minAge > 150) {
        showError('minAge', '1-150 ì‚¬ì´ì˜ ê°’ì„ ì…ë ¥í•˜ì„¸ìš”');
        valid = false;
      }

      if (valid && (currentYear - birthYear) < minAge) {
        showError('birthYear', `í˜„ì¬ ë‚˜ì´(${currentYear - birthYear})ê°€ ìµœì†Œ ë‚˜ì´(${minAge})ë³´ë‹¤ ì‘ìŠµë‹ˆë‹¤`);
        valid = false;
      }

      return valid;
    }

    // Age Verifier Request
    window.createAgeRequest = function() {
      if (!validateAgeInputs()) {
        log('ì…ë ¥ê°’ì„ í™•ì¸í•´ì£¼ì„¸ìš”', 'error');
        return;
      }

      // Use custom callback URL if provided, otherwise use server's callback endpoint
      const customCallbackUrl = document.getElementById('callbackUrl').value;
      const callbackUrl = customCallbackUrl || CALLBACK_URL;

      const request = {
        requestId: generateRequestId(),
        circuit: 'age_verifier',
        inputs: {
          birthYear: parseInt(document.getElementById('birthYear').value),
          currentYear: parseInt(document.getElementById('currentYear').value),
          minAge: parseInt(document.getElementById('minAge').value)
        },
        callbackUrl: callbackUrl,
        dappName: 'ProofPort Demo',
        message: 'ë‚˜ì´ ê²€ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤. í™•ì¸ í›„ ìë™ìœ¼ë¡œ ì¦ëª…ì´ ìƒì„±ë©ë‹ˆë‹¤.',
        createdAt: Date.now(),
        expiresAt: Date.now() + 600000
      };

      currentRequest = request;
      currentDeepLink = buildProofRequestUrl(request);

      showRequestResult(request, currentDeepLink, false);
      log(`Created age verification request: ${request.requestId}`, 'success');
      log(`Callback URL: ${callbackUrl}`, 'info');

      // Start polling for result
      startPolling(request.requestId);
    };

    window.createAgeQR = async function() {
      if (!validateAgeInputs()) {
        log('ì…ë ¥ê°’ì„ í™•ì¸í•´ì£¼ì„¸ìš”', 'error');
        return;
      }

      // Check if using localhost - warn user about QR code limitation
      const qrCallbackUrl = getQRCallbackUrl();
      if (!qrCallbackUrl) {
        const localIP = await getLocalIPHint();
        alert(`âš ï¸ QR ì½”ë“œ ì‚¬ìš© ì‹œ ì£¼ì˜!\n\n` +
              `í˜„ì¬ localhostë¡œ ì ‘ì† ì¤‘ì…ë‹ˆë‹¤.\n` +
              `ëª¨ë°”ì¼ ê¸°ê¸°ì—ì„œ QR ìŠ¤ìº” ì‹œ ì½œë°±ì„ ë°›ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\n\n` +
              `í•´ê²° ë°©ë²•:\n` +
              `1. Callback URLì— ì„œë²„ IP ì…ë ¥: http://${localIP}:3333/callback\n` +
              `2. ë˜ëŠ” http://${localIP}:3333 ìœ¼ë¡œ ì ‘ì†í•˜ì„¸ìš”`);
        log(`QR ì‚¬ìš© ì‹œ Callback URLì— ë¡œì»¬ IP ì…ë ¥ í•„ìš”: http://${localIP}:3333/callback`, 'warning');
      }

      // Use custom callback URL if provided, otherwise use server's callback endpoint
      const customCallbackUrl = document.getElementById('callbackUrl').value;
      const callbackUrl = customCallbackUrl || CALLBACK_URL;

      const request = {
        requestId: generateRequestId(),
        circuit: 'age_verifier',
        inputs: {
          birthYear: parseInt(document.getElementById('birthYear').value),
          currentYear: parseInt(document.getElementById('currentYear').value),
          minAge: parseInt(document.getElementById('minAge').value)
        },
        callbackUrl: callbackUrl,
        dappName: 'ProofPort Demo',
        message: 'ë‚˜ì´ ê²€ì¦ì´ í•„ìš”í•©ë‹ˆë‹¤. í™•ì¸ í›„ ìë™ìœ¼ë¡œ ì¦ëª…ì´ ìƒì„±ë©ë‹ˆë‹¤.',
        createdAt: Date.now(),
        expiresAt: Date.now() + 600000
      };

      currentRequest = request;
      currentDeepLink = buildProofRequestUrl(request);

      await showRequestResult(request, currentDeepLink, true);
      log(`Created QR code for age verification: ${request.requestId}`, 'success');
      log(`Callback URL: ${callbackUrl}`, 'info');

      // Start polling for result
      startPolling(request.requestId);
    };

    // Coinbase KYC Request (ì§€ê°‘ ì£¼ì†Œ ì…ë ¥ ë¶ˆí•„ìš”!)
    window.createCoinbaseRequest = function() {
      // Use custom callback URL if provided, otherwise use server's callback endpoint
      const customCallbackUrl = document.getElementById('coinbaseCallbackUrl').value;
      const callbackUrl = customCallbackUrl || CALLBACK_URL;

      const request = {
        requestId: generateRequestId(),
        circuit: 'coinbase_attestation',
        inputs: {
          // ì§€ê°‘ ì£¼ì†Œ ì—†ìŒ! ì•±ì—ì„œ ì—°ê²°í•˜ì—¬ ê°€ì ¸ì˜´
        },
        callbackUrl: callbackUrl,
        dappName: 'ProofPort Demo',
        message: document.getElementById('coinbaseMessage').value || 'Coinbase ë³¸ì¸ì¸ì¦ì„ ì¦ëª…í•´ì£¼ì„¸ìš”. ì•±ì—ì„œ ì§€ê°‘ì„ ì—°ê²°í•˜ë©´ ìë™ìœ¼ë¡œ ê²€ì¦ì´ ì‹œì‘ë©ë‹ˆë‹¤.',
        createdAt: Date.now(),
        expiresAt: Date.now() + 600000
      };

      currentRequest = request;
      currentDeepLink = buildProofRequestUrl(request);

      showRequestResult(request, currentDeepLink, false);
      log(`Created Coinbase KYC request: ${request.requestId}`, 'success');
      log(`Callback URL: ${callbackUrl}`, 'info');
      log('ì•±ì—ì„œ ì§€ê°‘ ì—°ê²° í›„ ìë™ìœ¼ë¡œ ê²€ì¦ì´ ì‹œì‘ë©ë‹ˆë‹¤', 'info');

      // Start polling for result
      startPolling(request.requestId);
    };

    window.createCoinbaseQR = async function() {
      // Check if using localhost - warn user about QR code limitation
      const qrCallbackUrl = getQRCallbackUrl();
      if (!qrCallbackUrl) {
        const localIP = await getLocalIPHint();
        alert(`âš ï¸ QR ì½”ë“œ ì‚¬ìš© ì‹œ ì£¼ì˜!\n\n` +
              `í˜„ì¬ localhostë¡œ ì ‘ì† ì¤‘ì…ë‹ˆë‹¤.\n` +
              `ëª¨ë°”ì¼ ê¸°ê¸°ì—ì„œ QR ìŠ¤ìº” ì‹œ ì½œë°±ì„ ë°›ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\n\n` +
              `í•´ê²° ë°©ë²•:\n` +
              `1. Callback URLì— ì„œë²„ IP ì…ë ¥: http://${localIP}:3333/callback\n` +
              `2. ë˜ëŠ” http://${localIP}:3333 ìœ¼ë¡œ ì ‘ì†í•˜ì„¸ìš”`);
        log(`QR ì‚¬ìš© ì‹œ Callback URLì— ë¡œì»¬ IP ì…ë ¥ í•„ìš”: http://${localIP}:3333/callback`, 'warning');
      }

      // Use custom callback URL if provided, otherwise use server's callback endpoint
      const customCallbackUrl = document.getElementById('coinbaseCallbackUrl').value;
      const callbackUrl = customCallbackUrl || CALLBACK_URL;

      const request = {
        requestId: generateRequestId(),
        circuit: 'coinbase_attestation',
        inputs: {
          // ì§€ê°‘ ì£¼ì†Œ ì—†ìŒ! ì•±ì—ì„œ ì—°ê²°í•˜ì—¬ ê°€ì ¸ì˜´
        },
        callbackUrl: callbackUrl,
        dappName: 'ProofPort Demo',
        message: document.getElementById('coinbaseMessage').value || 'Coinbase ë³¸ì¸ì¸ì¦ì„ ì¦ëª…í•´ì£¼ì„¸ìš”. ì•±ì—ì„œ ì§€ê°‘ì„ ì—°ê²°í•˜ë©´ ìë™ìœ¼ë¡œ ê²€ì¦ì´ ì‹œì‘ë©ë‹ˆë‹¤.',
        createdAt: Date.now(),
        expiresAt: Date.now() + 600000
      };

      currentRequest = request;
      currentDeepLink = buildProofRequestUrl(request);

      await showRequestResult(request, currentDeepLink, true);
      log(`Created QR code for Coinbase KYC: ${request.requestId}`, 'success');
      log(`Callback URL: ${callbackUrl}`, 'info');
      log('ì•±ì—ì„œ ì§€ê°‘ ì—°ê²° í›„ ìë™ìœ¼ë¡œ ê²€ì¦ì´ ì‹œì‘ë©ë‹ˆë‹¤', 'info');

      // Start polling for result
      startPolling(request.requestId);
    };

    async function showRequestResult(request, deepLink, showQR) {
      const resultDiv = document.getElementById('request-result');
      resultDiv.classList.remove('hidden');

      document.getElementById('request-id').textContent = request.requestId;
      document.getElementById('request-circuit').textContent = request.circuit;
      document.getElementById('request-status').textContent = 'Pending';
      document.getElementById('request-status').className = 'status-badge pending';

      const qrDisplay = document.getElementById('qr-display');
      const deeplinkDisplay = document.getElementById('deeplink-display');

      if (showQR) {
        const QRCode = await import('https://cdn.jsdelivr.net/npm/qrcode@1.5.3/+esm');
        const qrDataUrl = await QRCode.toDataURL(deepLink, {
          width: 250,
          margin: 2,
          color: { dark: '#000000', light: '#ffffff' }
        });
        document.getElementById('qr-image').src = qrDataUrl;
        qrDisplay.classList.remove('hidden');
        deeplinkDisplay.classList.add('hidden');
      } else {
        document.getElementById('deeplink-url').textContent = deepLink;
        deeplinkDisplay.classList.remove('hidden');
        qrDisplay.classList.add('hidden');
      }
    }

    window.openDeepLink = function() {
      if (currentDeepLink) {
        log(`Opening deep link: ${currentDeepLink.substring(0, 50)}...`);
        window.location.href = currentDeepLink;
      }
    };

    window.copyDeepLink = function() {
      if (currentDeepLink) {
        navigator.clipboard.writeText(currentDeepLink);
        log('Deep link copied to clipboard', 'success');
      }
    };

    // On-chain verification
    window.verifyProofOnChain = async function() {
      const proof = document.getElementById('proofInput').value;
      const publicInputsStr = document.getElementById('publicInputsInput').value;
      const circuit = document.getElementById('verifyCircuit').value;

      if (!proof) {
        log('Please enter proof', 'error');
        return;
      }

      const publicInputs = publicInputsStr.split(',').map(s => s.trim()).filter(s => s);

      log(`Starting on-chain verification for ${circuit}...`);

      const verifierAddresses = {
        age_verifier: '0x33316f0A1F6638AbC8D5a6aCce5a1cF13427A0c9',
        coinbase_attestation: '0x121632902482B658e0F2D055126dBe977deb9FC1'
      };

      try {
        const { ethers } = await import('https://cdn.jsdelivr.net/npm/ethers@5.7.2/dist/ethers.esm.min.js');

        const provider = new ethers.providers.JsonRpcProvider(
          'https://sepolia.infura.io/v3/2fe2d28467784ababcae918bb18b4bf6'
        );

        const contract = new ethers.Contract(
          verifierAddresses[circuit],
          ['function verify(bytes calldata _proof, bytes32[] calldata _publicInputs) external view returns (bool)'],
          provider
        );

        const publicInputsBytes32 = publicInputs.map(input => {
          const hex = input.startsWith('0x') ? input : `0x${input}`;
          return ethers.utils.hexZeroPad(hex, 32);
        });

        log(`Calling verifier contract at ${verifierAddresses[circuit]}...`);

        const isValid = await contract.verify(proof, publicInputsBytes32);

        const resultDiv = document.getElementById('verify-result');
        resultDiv.classList.remove('hidden');

        if (isValid) {
          resultDiv.innerHTML = `
            <div class="result success">
              <div class="result-title">âœ… Verification Successful</div>
              <p>The proof is valid on Sepolia testnet.</p>
              <p style="font-size: 0.75rem; color: var(--text-muted); margin-top: 0.5rem;">
                Verifier: ${verifierAddresses[circuit]}
              </p>
            </div>
          `;
          log('Proof verified successfully!', 'success');
        } else {
          resultDiv.innerHTML = `
            <div class="result error">
              <div class="result-title">âŒ Verification Failed</div>
              <p>The proof is invalid.</p>
            </div>
          `;
          log('Proof verification failed', 'error');
        }
      } catch (error) {
        log(`Verification error: ${error.message}`, 'error');
        const resultDiv = document.getElementById('verify-result');
        resultDiv.classList.remove('hidden');
        resultDiv.innerHTML = `
          <div class="result error">
            <div class="result-title">âŒ Error</div>
            <p>${error.message}</p>
          </div>
        `;
      }
    };

    // Check for callback response on page load
    function checkCallbackResponse() {
      const params = new URLSearchParams(window.location.search);
      const requestId = params.get('requestId');
      const status = params.get('status');

      if (requestId && status) {
        log(`=== Callback Response Received ===`, 'info');
        log(`Request ID: ${requestId}`, 'info');
        log(`Status: ${status}`, status === 'completed' ? 'success' : 'error');

        const resultDiv = document.getElementById('request-result');
        resultDiv.classList.remove('hidden');
        document.getElementById('request-id').textContent = requestId;

        if (status === 'completed') {
          const proof = params.get('proof');
          const publicInputs = params.get('publicInputs');
          const circuit = params.get('circuit');
          const numPublicInputs = params.get('numPublicInputs');

          if (proof) {
            document.getElementById('proofInput').value = proof;
            log(`Proof: ${proof.substring(0, 60)}...`, 'success');
          }
          if (publicInputs) {
            document.getElementById('publicInputsInput').value = publicInputs;
            log(`Public Inputs: ${publicInputs}`, 'success');
          }
          if (circuit) {
            document.getElementById('verifyCircuit').value = circuit;
            document.getElementById('request-circuit').textContent = circuit;
            log(`Circuit: ${circuit}`, 'info');
          }
          if (numPublicInputs) {
            log(`Number of Public Inputs: ${numPublicInputs}`, 'info');
          }

          document.getElementById('request-status').textContent = 'Completed';
          document.getElementById('request-status').className = 'status-badge completed';

          // Hide QR/deeplink displays, show success message
          document.getElementById('qr-display').classList.add('hidden');
          document.getElementById('deeplink-display').classList.add('hidden');

          // Show success result in request-result
          const successHtml = `
            <div class="result success" style="margin-top: 1rem;">
              <div class="result-title">âœ… Proof Received from App!</div>
              <p>The ZK proof has been successfully generated and sent back.</p>
              <p style="font-size: 0.875rem; margin-top: 0.5rem;">
                You can now verify the proof on-chain using the Verification section below.
              </p>
            </div>
          `;
          resultDiv.insertAdjacentHTML('beforeend', successHtml);

          // Scroll to verification section
          document.getElementById('verify-section').scrollIntoView({ behavior: 'smooth', block: 'start' });

          log('=== Ready for On-chain Verification ===', 'success');
          log('Click "On-chain ê²€ì¦" button below to verify the proof on Sepolia', 'info');

        } else if (status === 'error') {
          const error = params.get('error');
          log(`Error from app: ${error}`, 'error');

          document.getElementById('request-status').textContent = 'Error';
          document.getElementById('request-status').className = 'status-badge error';

          // Show error in request-result
          const errorHtml = `
            <div class="result error" style="margin-top: 1rem;">
              <div class="result-title">âŒ Error</div>
              <p>${error || 'Unknown error occurred'}</p>
            </div>
          `;
          resultDiv.insertAdjacentHTML('beforeend', errorHtml);

        } else if (status === 'cancelled') {
          log('Request was cancelled by user', 'warning');

          document.getElementById('request-status').textContent = 'Cancelled';
          document.getElementById('request-status').className = 'status-badge error';

          // Show cancelled in request-result
          const cancelHtml = `
            <div class="result error" style="margin-top: 1rem;">
              <div class="result-title">ğŸš« Cancelled</div>
              <p>The user cancelled the proof request.</p>
            </div>
          `;
          resultDiv.insertAdjacentHTML('beforeend', cancelHtml);
        }

        // Clean URL
        window.history.replaceState({}, '', window.location.pathname);
      }
    }

    // Initialize
    checkCallbackResponse();

    // Set default callback URLs
    document.getElementById('callbackUrl').value = CALLBACK_URL;
    document.getElementById('coinbaseCallbackUrl').value = CALLBACK_URL;

    log('ProofPort SDK Demo initialized', 'info');
  </script>
</body>
</html>
